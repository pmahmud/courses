~-------------------------------------------------------------------------------------------
:: Firebase Fundamental ::
~-------------------------------------------------------------------------------------------
9:13 PM 12/6/2016
~-------------------------------------------------------------------------------------------

# NoSQL
	- better at scaling
	- drawback: eventual consistency

# type:
	- key/value: SimpleDB, RedisDB
	- document: Mongo, RethinkDB, CouchDB
	- Column: similar to key/value pair, one big giant table: multiple key: Casendra, HSpace
	- Graph: neo4j, infinigraph
	
# Firebase
	- Key/Value
	- URL oriented
	- Think as a Large tree/JSON graph
		- Each node has a ref URL
	- Real-time
	- Integrated Authentication
	
# URL	
	- each node represent a json tree/JSON
	- If you want to get JSOn just add .json at the end of the URL

# Architecture:
	
	- Client <---> Firebase
	
				  |------>Server
	- Client<------
				  |------>Firebase

				  |------>Server
	- Client<------          |
				  |------>Firebase

				  |------>Server<-------> Database
	- Client<------          |
				  |------>Firebase


# Data
	- indexing: hashkey based indexing: each node has an unique key
	- no conflicts when multiple user manipulates one piece of data in realtime
	
# Null node:
	- if an URL does not map to a real node in the db, it will return null
	
# Ref
	const url = "http://blah.firebase.io/";
	const baseRef = new Firebase(url);
	const hobbitRef = new Firebase(url + 'hobbit/');
 
	- no overhead and very cheap to do so
	
# Child, Parent and Root ref
	const url = "http://blah.firebase.io/";
	const moviesRef = new Firebase(url + 'movies/');
	const hobbitRef = moviesRef.child('star_wars');
	moviesRef = hobbitRef.parent();
	baseRef = hobbitRef.root();
	
# Data design principles:
	- Don't treat it like a relational DB
	- Use root branches as the primarty container
	- Avoid deep nesting
	- Use shallow nesting
	- Duplicate data at the right place
		- duplicate data whenever needed
		- like followers name and email can be copied. 
		  if more detailed information is needed then it can use the unique_key to go and query that user for more info.
	- Design Around data access
		- design is driven by data access needs
		- iterative design
		
	UserObject:
		- followers:
			- userID
				- followers array
			- name (duplicate)
			- email (duplicate)
		- tweets
			- userID
				- created
				- text
	Users:
		- userID
		- email
		- name
		
::=====================================================================::
:: Reading Data ::
::=====================================================================::

on()
	- when data is receiving updatqe

once()
	- read data once
	